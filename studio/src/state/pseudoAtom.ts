import * as Predicate from 'studio/blueprint/predicate';
import * as Rule from 'studio/blueprint/rule';
import assert from 'studio/util/assert';
import {UUID} from 'studio/util/types';
import {isNonemptyArray} from 'studio/util/types';
import {v4 as uuidv4} from 'uuid';

export type t = {
  fields: string[];
  predicate: Predicate.t;
  name: string | undefined;
  uuid: UUID;
};

function allEqual<T>(xs: T[]): boolean {
  const s = new Set<T>();
  xs.forEach(x => s.add(x));
  return s.size <= 1;
}

export function toRule(pseudoAtom: t): Rule.t {
  if (pseudoAtom.fields.length <= 2) {
    return {
      type: 'atom',
      ...pseudoAtom,
    };
  } else {
    const rules: Rule.Atom[] = [];
    for (let i = 0; i < pseudoAtom.fields.length; ++i) {
      for (let j = i + 1; j < pseudoAtom.fields.length; ++j) {
        rules.push({
          type: 'atom',
          fields: [pseudoAtom.fields[i], pseudoAtom.fields[j]],
          predicate: pseudoAtom.predicate,
          name: pseudoAtom.name,
          uuid: uuidv4(),
        });
      }
    }
    return {
      type: 'conjunction',
      rules,
      name: pseudoAtom.name,
      uuid: pseudoAtom.uuid,
    };
  }
}

export function fromRule(rule: Rule.t): t | undefined {
  if (rule.type == 'atom') {
    const {type, ...pseudoAtom} = rule;
    return pseudoAtom;
  } else if (rule.type == 'conjunction') {
    return fromConjunction(rule);
  }
}

function fromConjunction(rule: Rule.Conjunction): t | undefined {
  for (let subrule of rule.rules) {
    if (subrule.type != 'atom' || subrule.fields.length != 2) {
      return undefined;
    }
  }

  const fields = fieldsInOrder(rule);

  let predicate: Predicate.t | undefined = undefined;

  for (let subrule of rule.rules) {
    assert(subrule.type == 'atom');
    if (predicate == undefined) {
      predicate = subrule.predicate;
    } else if (predicate.name != subrule.predicate.name) {
      // We are ignoring if individual subpredicates have been tweaked.
      return undefined;
    }
  }

  const N = fields.length;
  const T = (N - 1) * N / 2;
  if (T != rule.rules.length) {
    return undefined;
  }

  // This checks that the subrules are in the same order with the same
  // fields as that generated by the UI / synthesis when building these
  // fake multi-field rules.
  for (let i = 0; i < N; ++i) {
    for (let j = i + 1; j < N; ++j) {
      const index = T - (N - i - 1) * (N - i) / 2 + (j - (i + 1));
      assert(0 <= index && index < T);
      const subrule = rule.rules[index];
      assert(subrule.type == 'atom');
      if (subrule.fields[0] != fields[i] ||
          subrule.fields[1] != fields[j])
      {
        return undefined;
      }
    }
  }

  if (fields.length > 0 && predicate != undefined) {
    return {
      fields,
      predicate,
      uuid: rule.uuid,
      name: rule.name,
    };
  }
}

function fieldsInOrder(rule: Rule.Conjunction): string[] {
  // Janky. This order is not used except by the UI...
  const result: string[] = [];
  for (let subrule of rule.rules) {
    assert(subrule.type == 'atom');
    assert(subrule.fields.length == 2);
    for (let field of subrule.fields) {
      if (!result.includes(field)) {
        result.push(field);
      }
    }
  }
  return result;
}

export function withIthField(pa: t, i: number, field: string): t {
  const newFields = [...pa.fields];
  newFields[i] = field;
  return {...pa, fields: newFields};
}

export function withIthFieldDeleted(pa: t, i: number): t {
  const newFields = [...pa.fields];
  newFields.splice(i, 1);
  return {...pa, fields: newFields};
}

export function minNumFields(predicate: Predicate.t): number {
  switch (predicate.name) {
  case 'text_equals':
    return 1;
  case 'bottom_aligned':
  case 'left_aligned':
  case 'right_aligned':
  case 'left_to_right':
  case 'top_down':
  case 'are_on_same_page':
  case 'nothing_between_horizontally':
  case 'nothing_between_vertically':
  case 'no_words_between_horizontally':
  case 'no_words_between_vertically':
    return 2;
  }
  return <never>0;
}

export function maxNumFields(predicate: Predicate.t): number | undefined {
  switch (predicate.name) {
  case 'text_equals':
    return 1;
  case 'nothing_between_horizontally':
  case 'nothing_between_vertically':
  case 'no_words_between_horizontally':
  case 'no_words_between_vertically':
    return 2;
  case 'bottom_aligned':
  case 'left_aligned':
  case 'right_aligned':
  case 'left_to_right':
  case 'top_down':
  case 'are_on_same_page':
    return undefined;
  }
  return <never>0;
}
